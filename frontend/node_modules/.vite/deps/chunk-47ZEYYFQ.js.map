{
  "version": 3,
  "sources": ["../../refractor/lang/graphql.js"],
  "sourcesContent": ["'use strict'\r\n\r\nmodule.exports = graphql\r\ngraphql.displayName = 'graphql'\r\ngraphql.aliases = []\r\nfunction graphql(Prism) {\r\n  Prism.languages.graphql = {\r\n    comment: /#.*/,\r\n    description: {\r\n      pattern:\r\n        /(?:\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")(?=\\s*[a-z_])/i,\r\n      greedy: true,\r\n      alias: 'string',\r\n      inside: {\r\n        'language-markdown': {\r\n          pattern: /(^\"(?:\"\")?)(?!\\1)[\\s\\S]+(?=\\1$)/,\r\n          lookbehind: true,\r\n          inside: Prism.languages.markdown\r\n        }\r\n      }\r\n    },\r\n    string: {\r\n      pattern: /\"\"\"(?:[^\"]|(?!\"\"\")\")*\"\"\"|\"(?:\\\\.|[^\\\\\"\\r\\n])*\"/,\r\n      greedy: true\r\n    },\r\n    number: /(?:\\B-|\\b)\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\r\n    boolean: /\\b(?:false|true)\\b/,\r\n    variable: /\\$[a-z_]\\w*/i,\r\n    directive: {\r\n      pattern: /@[a-z_]\\w*/i,\r\n      alias: 'function'\r\n    },\r\n    'attr-name': {\r\n      pattern: /\\b[a-z_]\\w*(?=\\s*(?:\\((?:[^()\"]|\"(?:\\\\.|[^\\\\\"\\r\\n])*\")*\\))?:)/i,\r\n      greedy: true\r\n    },\r\n    'atom-input': {\r\n      pattern: /\\b[A-Z]\\w*Input\\b/,\r\n      alias: 'class-name'\r\n    },\r\n    scalar: /\\b(?:Boolean|Float|ID|Int|String)\\b/,\r\n    constant: /\\b[A-Z][A-Z_\\d]*\\b/,\r\n    'class-name': {\r\n      pattern:\r\n        /(\\b(?:enum|implements|interface|on|scalar|type|union)\\s+|&\\s*|:\\s*|\\[)[A-Z_]\\w*/,\r\n      lookbehind: true\r\n    },\r\n    fragment: {\r\n      pattern: /(\\bfragment\\s+|\\.{3}\\s*(?!on\\b))[a-zA-Z_]\\w*/,\r\n      lookbehind: true,\r\n      alias: 'function'\r\n    },\r\n    'definition-mutation': {\r\n      pattern: /(\\bmutation\\s+)[a-zA-Z_]\\w*/,\r\n      lookbehind: true,\r\n      alias: 'function'\r\n    },\r\n    'definition-query': {\r\n      pattern: /(\\bquery\\s+)[a-zA-Z_]\\w*/,\r\n      lookbehind: true,\r\n      alias: 'function'\r\n    },\r\n    keyword:\r\n      /\\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\\b/,\r\n    operator: /[!=|&]|\\.{3}/,\r\n    'property-query': /\\w+(?=\\s*\\()/,\r\n    object: /\\w+(?=\\s*\\{)/,\r\n    punctuation: /[!(){}\\[\\]:=,]/,\r\n    property: /\\w+/\r\n  }\r\n  Prism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {\r\n    if (env.language !== 'graphql') {\r\n      return\r\n    }\r\n    /**\r\n     * get the graphql token stream that we want to customize\r\n     *\r\n     * @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token\r\n     * @type {Token[]}\r\n     */\r\n    var validTokens = env.tokens.filter(function (token) {\r\n      return (\r\n        typeof token !== 'string' &&\r\n        token.type !== 'comment' &&\r\n        token.type !== 'scalar'\r\n      )\r\n    })\r\n    var currentIndex = 0\r\n    /**\r\n     * Returns whether the token relative to the current index has the given type.\r\n     *\r\n     * @param {number} offset\r\n     * @returns {Token | undefined}\r\n     */\r\n    function getToken(offset) {\r\n      return validTokens[currentIndex + offset]\r\n    }\r\n    /**\r\n     * Returns whether the token relative to the current index has the given type.\r\n     *\r\n     * @param {readonly string[]} types\r\n     * @param {number} [offset=0]\r\n     * @returns {boolean}\r\n     */\r\n    function isTokenType(types, offset) {\r\n      offset = offset || 0\r\n      for (var i = 0; i < types.length; i++) {\r\n        var token = getToken(i + offset)\r\n        if (!token || token.type !== types[i]) {\r\n          return false\r\n        }\r\n      }\r\n      return true\r\n    }\r\n    /**\r\n     * Returns the index of the closing bracket to an opening bracket.\r\n     *\r\n     * It is assumed that `token[currentIndex - 1]` is an opening bracket.\r\n     *\r\n     * If no closing bracket could be found, `-1` will be returned.\r\n     *\r\n     * @param {RegExp} open\r\n     * @param {RegExp} close\r\n     * @returns {number}\r\n     */\r\n    function findClosingBracket(open, close) {\r\n      var stackHeight = 1\r\n      for (var i = currentIndex; i < validTokens.length; i++) {\r\n        var token = validTokens[i]\r\n        var content = token.content\r\n        if (token.type === 'punctuation' && typeof content === 'string') {\r\n          if (open.test(content)) {\r\n            stackHeight++\r\n          } else if (close.test(content)) {\r\n            stackHeight--\r\n            if (stackHeight === 0) {\r\n              return i\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return -1\r\n    }\r\n    /**\r\n     * Adds an alias to the given token.\r\n     *\r\n     * @param {Token} token\r\n     * @param {string} alias\r\n     * @returns {void}\r\n     */\r\n    function addAlias(token, alias) {\r\n      var aliases = token.alias\r\n      if (!aliases) {\r\n        token.alias = aliases = []\r\n      } else if (!Array.isArray(aliases)) {\r\n        token.alias = aliases = [aliases]\r\n      }\r\n      aliases.push(alias)\r\n    }\r\n    for (; currentIndex < validTokens.length; ) {\r\n      var startToken = validTokens[currentIndex++] // add special aliases for mutation tokens\r\n      if (startToken.type === 'keyword' && startToken.content === 'mutation') {\r\n        // any array of the names of all input variables (if any)\r\n        var inputVariables = []\r\n        if (\r\n          isTokenType(['definition-mutation', 'punctuation']) &&\r\n          getToken(1).content === '('\r\n        ) {\r\n          // definition\r\n          currentIndex += 2 // skip 'definition-mutation' and 'punctuation'\r\n          var definitionEnd = findClosingBracket(/^\\($/, /^\\)$/)\r\n          if (definitionEnd === -1) {\r\n            continue\r\n          } // find all input variables\r\n          for (; currentIndex < definitionEnd; currentIndex++) {\r\n            var t = getToken(0)\r\n            if (t.type === 'variable') {\r\n              addAlias(t, 'variable-input')\r\n              inputVariables.push(t.content)\r\n            }\r\n          }\r\n          currentIndex = definitionEnd + 1\r\n        }\r\n        if (\r\n          isTokenType(['punctuation', 'property-query']) &&\r\n          getToken(0).content === '{'\r\n        ) {\r\n          currentIndex++ // skip opening bracket\r\n          addAlias(getToken(0), 'property-mutation')\r\n          if (inputVariables.length > 0) {\r\n            var mutationEnd = findClosingBracket(/^\\{$/, /^\\}$/)\r\n            if (mutationEnd === -1) {\r\n              continue\r\n            } // give references to input variables a special alias\r\n            for (var i = currentIndex; i < mutationEnd; i++) {\r\n              var varToken = validTokens[i]\r\n              if (\r\n                varToken.type === 'variable' &&\r\n                inputVariables.indexOf(varToken.content) >= 0\r\n              ) {\r\n                addAlias(varToken, 'variable-input')\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  })\r\n}\r\n"],
  "mappings": "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",
  "names": ["i"]
}
