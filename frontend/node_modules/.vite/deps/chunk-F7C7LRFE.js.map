{
  "version": 3,
  "sources": ["../../refractor/lang/smali.js"],
  "sourcesContent": ["'use strict'\r\n\r\nmodule.exports = smali\r\nsmali.displayName = 'smali'\r\nsmali.aliases = []\r\nfunction smali(Prism) {\r\n  // Test files for the parser itself:\r\n  // https://github.com/JesusFreke/smali/tree/master/smali/src/test/resources/LexerTest\r\n  Prism.languages.smali = {\r\n    comment: /#.*/,\r\n    string: {\r\n      pattern: /\"(?:[^\\r\\n\\\\\"]|\\\\.)*\"|'(?:[^\\r\\n\\\\']|\\\\(?:.|u[\\da-fA-F]{4}))'/,\r\n      greedy: true\r\n    },\r\n    'class-name': {\r\n      pattern:\r\n        /(^|[^L])L(?:(?:\\w+|`[^`\\r\\n]*`)\\/)*(?:[\\w$]+|`[^`\\r\\n]*`)(?=\\s*;)/,\r\n      lookbehind: true,\r\n      inside: {\r\n        'class-name': {\r\n          pattern: /(^L|\\/)(?:[\\w$]+|`[^`\\r\\n]*`)$/,\r\n          lookbehind: true\r\n        },\r\n        namespace: {\r\n          pattern: /^(L)(?:(?:\\w+|`[^`\\r\\n]*`)\\/)+/,\r\n          lookbehind: true,\r\n          inside: {\r\n            punctuation: /\\//\r\n          }\r\n        },\r\n        builtin: /^L/\r\n      }\r\n    },\r\n    builtin: [\r\n      {\r\n        // Reference: https://github.com/JesusFreke/smali/wiki/TypesMethodsAndFields#types\r\n        pattern: /([();\\[])[BCDFIJSVZ]+/,\r\n        lookbehind: true\r\n      },\r\n      {\r\n        // e.g. .field mWifiOnUid:I\r\n        pattern: /([\\w$>]:)[BCDFIJSVZ]/,\r\n        lookbehind: true\r\n      }\r\n    ],\r\n    keyword: [\r\n      {\r\n        pattern: /(\\.end\\s+)[\\w-]+/,\r\n        lookbehind: true\r\n      },\r\n      {\r\n        pattern: /(^|[^\\w.-])\\.(?!\\d)[\\w-]+/,\r\n        lookbehind: true\r\n      },\r\n      {\r\n        pattern:\r\n          /(^|[^\\w.-])(?:abstract|annotation|bridge|constructor|enum|final|interface|private|protected|public|runtime|static|synthetic|system|transient)(?![\\w.-])/,\r\n        lookbehind: true\r\n      }\r\n    ],\r\n    function: {\r\n      pattern: /(^|[^\\w.-])(?:\\w+|<[\\w$-]+>)(?=\\()/,\r\n      lookbehind: true\r\n    },\r\n    field: {\r\n      pattern: /[\\w$]+(?=:)/,\r\n      alias: 'variable'\r\n    },\r\n    register: {\r\n      pattern: /(^|[^\\w.-])[vp]\\d(?![\\w.-])/,\r\n      lookbehind: true,\r\n      alias: 'variable'\r\n    },\r\n    boolean: {\r\n      pattern: /(^|[^\\w.-])(?:false|true)(?![\\w.-])/,\r\n      lookbehind: true\r\n    },\r\n    number: {\r\n      pattern:\r\n        /(^|[^/\\w.-])-?(?:NAN|INFINITY|0x(?:[\\dA-F]+(?:\\.[\\dA-F]*)?|\\.[\\dA-F]+)(?:p[+-]?[\\dA-F]+)?|(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?)[dflst]?(?![\\w.-])/i,\r\n      lookbehind: true\r\n    },\r\n    label: {\r\n      pattern: /(:)\\w+/,\r\n      lookbehind: true,\r\n      alias: 'property'\r\n    },\r\n    operator: /->|\\.\\.|[\\[=]/,\r\n    punctuation: /[{}(),;:]/\r\n  }\r\n}\r\n"],
  "mappings": ";;;;;AAAA;AAAA;AAEA,WAAO,UAAU;AACjB,UAAM,cAAc;AACpB,UAAM,UAAU,CAAC;AACjB,aAAS,MAAM,OAAO;AAGpB,YAAM,UAAU,QAAQ;AAAA,QACtB,SAAS;AAAA,QACT,QAAQ;AAAA,UACN,SAAS;AAAA,UACT,QAAQ;AAAA,QACV;AAAA,QACA,cAAc;AAAA,UACZ,SACE;AAAA,UACF,YAAY;AAAA,UACZ,QAAQ;AAAA,YACN,cAAc;AAAA,cACZ,SAAS;AAAA,cACT,YAAY;AAAA,YACd;AAAA,YACA,WAAW;AAAA,cACT,SAAS;AAAA,cACT,YAAY;AAAA,cACZ,QAAQ;AAAA,gBACN,aAAa;AAAA,cACf;AAAA,YACF;AAAA,YACA,SAAS;AAAA,UACX;AAAA,QACF;AAAA,QACA,SAAS;AAAA,UACP;AAAA;AAAA,YAEE,SAAS;AAAA,YACT,YAAY;AAAA,UACd;AAAA,UACA;AAAA;AAAA,YAEE,SAAS;AAAA,YACT,YAAY;AAAA,UACd;AAAA,QACF;AAAA,QACA,SAAS;AAAA,UACP;AAAA,YACE,SAAS;AAAA,YACT,YAAY;AAAA,UACd;AAAA,UACA;AAAA,YACE,SAAS;AAAA,YACT,YAAY;AAAA,UACd;AAAA,UACA;AAAA,YACE,SACE;AAAA,YACF,YAAY;AAAA,UACd;AAAA,QACF;AAAA,QACA,UAAU;AAAA,UACR,SAAS;AAAA,UACT,YAAY;AAAA,QACd;AAAA,QACA,OAAO;AAAA,UACL,SAAS;AAAA,UACT,OAAO;AAAA,QACT;AAAA,QACA,UAAU;AAAA,UACR,SAAS;AAAA,UACT,YAAY;AAAA,UACZ,OAAO;AAAA,QACT;AAAA,QACA,SAAS;AAAA,UACP,SAAS;AAAA,UACT,YAAY;AAAA,QACd;AAAA,QACA,QAAQ;AAAA,UACN,SACE;AAAA,UACF,YAAY;AAAA,QACd;AAAA,QACA,OAAO;AAAA,UACL,SAAS;AAAA,UACT,YAAY;AAAA,UACZ,OAAO;AAAA,QACT;AAAA,QACA,UAAU;AAAA,QACV,aAAa;AAAA,MACf;AAAA,IACF;AAAA;AAAA;",
  "names": []
}
