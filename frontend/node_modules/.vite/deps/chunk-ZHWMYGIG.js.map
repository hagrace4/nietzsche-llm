{
  "version": 3,
  "sources": ["../../refractor/lang/lisp.js"],
  "sourcesContent": ["'use strict'\r\n\r\nmodule.exports = lisp\r\nlisp.displayName = 'lisp'\r\nlisp.aliases = []\r\nfunction lisp(Prism) {\r\n  ;(function (Prism) {\r\n    /**\r\n     * Functions to construct regular expressions\r\n     * e.g. (interactive ... or (interactive)\r\n     *\r\n     * @param {string} name\r\n     * @returns {RegExp}\r\n     */\r\n    function simple_form(name) {\r\n      return RegExp(/(\\()/.source + '(?:' + name + ')' + /(?=[\\s\\)])/.source)\r\n    }\r\n    /**\r\n     * booleans and numbers\r\n     *\r\n     * @param {string} pattern\r\n     * @returns {RegExp}\r\n     */\r\n    function primitive(pattern) {\r\n      return RegExp(\r\n        /([\\s([])/.source + '(?:' + pattern + ')' + /(?=[\\s)])/.source\r\n      )\r\n    } // Patterns in regular expressions\r\n    // Symbol name. See https://www.gnu.org/software/emacs/manual/html_node/elisp/Symbol-Type.html\r\n    // & and : are excluded as they are usually used for special purposes\r\n    var symbol = /(?!\\d)[-+*/~!@$%^=<>{}\\w]+/.source // symbol starting with & used in function arguments\r\n    var marker = '&' + symbol // Open parenthesis for look-behind\r\n    var par = '(\\\\()'\r\n    var endpar = '(?=\\\\))' // End the pattern with look-ahead space\r\n    var space = '(?=\\\\s)'\r\n    var nestedPar =\r\n      /(?:[^()]|\\((?:[^()]|\\((?:[^()]|\\((?:[^()]|\\((?:[^()]|\\([^()]*\\))*\\))*\\))*\\))*\\))*/\r\n        .source\r\n    var language = {\r\n      // Three or four semicolons are considered a heading.\r\n      // See https://www.gnu.org/software/emacs/manual/html_node/elisp/Comment-Tips.html\r\n      heading: {\r\n        pattern: /;;;.*/,\r\n        alias: ['comment', 'title']\r\n      },\r\n      comment: /;.*/,\r\n      string: {\r\n        pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\r\n        greedy: true,\r\n        inside: {\r\n          argument: /[-A-Z]+(?=[.,\\s])/,\r\n          symbol: RegExp('`' + symbol + \"'\")\r\n        }\r\n      },\r\n      'quoted-symbol': {\r\n        pattern: RegExp(\"#?'\" + symbol),\r\n        alias: ['variable', 'symbol']\r\n      },\r\n      'lisp-property': {\r\n        pattern: RegExp(':' + symbol),\r\n        alias: 'property'\r\n      },\r\n      splice: {\r\n        pattern: RegExp(',@?' + symbol),\r\n        alias: ['symbol', 'variable']\r\n      },\r\n      keyword: [\r\n        {\r\n          pattern: RegExp(\r\n            par +\r\n              '(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\\\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)' +\r\n              space\r\n          ),\r\n          lookbehind: true\r\n        },\r\n        {\r\n          pattern: RegExp(\r\n            par +\r\n              '(?:append|by|collect|concat|do|finally|for|in|return)' +\r\n              space\r\n          ),\r\n          lookbehind: true\r\n        }\r\n      ],\r\n      declare: {\r\n        pattern: simple_form(/declare/.source),\r\n        lookbehind: true,\r\n        alias: 'keyword'\r\n      },\r\n      interactive: {\r\n        pattern: simple_form(/interactive/.source),\r\n        lookbehind: true,\r\n        alias: 'keyword'\r\n      },\r\n      boolean: {\r\n        pattern: primitive(/nil|t/.source),\r\n        lookbehind: true\r\n      },\r\n      number: {\r\n        pattern: primitive(/[-+]?\\d+(?:\\.\\d*)?/.source),\r\n        lookbehind: true\r\n      },\r\n      defvar: {\r\n        pattern: RegExp(par + 'def(?:const|custom|group|var)\\\\s+' + symbol),\r\n        lookbehind: true,\r\n        inside: {\r\n          keyword: /^def[a-z]+/,\r\n          variable: RegExp(symbol)\r\n        }\r\n      },\r\n      defun: {\r\n        pattern: RegExp(\r\n          par +\r\n            /(?:cl-)?(?:defmacro|defun\\*?)\\s+/.source +\r\n            symbol +\r\n            /\\s+\\(/.source +\r\n            nestedPar +\r\n            /\\)/.source\r\n        ),\r\n        lookbehind: true,\r\n        greedy: true,\r\n        inside: {\r\n          keyword: /^(?:cl-)?def\\S+/,\r\n          // See below, this property needs to be defined later so that it can\r\n          // reference the language object.\r\n          arguments: null,\r\n          function: {\r\n            pattern: RegExp('(^\\\\s)' + symbol),\r\n            lookbehind: true\r\n          },\r\n          punctuation: /[()]/\r\n        }\r\n      },\r\n      lambda: {\r\n        pattern: RegExp(\r\n          par +\r\n            'lambda\\\\s+\\\\(\\\\s*(?:&?' +\r\n            symbol +\r\n            '(?:\\\\s+&?' +\r\n            symbol +\r\n            ')*\\\\s*)?\\\\)'\r\n        ),\r\n        lookbehind: true,\r\n        greedy: true,\r\n        inside: {\r\n          keyword: /^lambda/,\r\n          // See below, this property needs to be defined later so that it can\r\n          // reference the language object.\r\n          arguments: null,\r\n          punctuation: /[()]/\r\n        }\r\n      },\r\n      car: {\r\n        pattern: RegExp(par + symbol),\r\n        lookbehind: true\r\n      },\r\n      punctuation: [\r\n        // open paren, brackets, and close paren\r\n        /(?:['`,]?\\(|[)\\[\\]])/, // cons\r\n        {\r\n          pattern: /(\\s)\\.(?=\\s)/,\r\n          lookbehind: true\r\n        }\r\n      ]\r\n    }\r\n    var arg = {\r\n      'lisp-marker': RegExp(marker),\r\n      varform: {\r\n        pattern: RegExp(\r\n          /\\(/.source + symbol + /\\s+(?=\\S)/.source + nestedPar + /\\)/.source\r\n        ),\r\n        inside: language\r\n      },\r\n      argument: {\r\n        pattern: RegExp(/(^|[\\s(])/.source + symbol),\r\n        lookbehind: true,\r\n        alias: 'variable'\r\n      },\r\n      rest: language\r\n    }\r\n    var forms = '\\\\S+(?:\\\\s+\\\\S+)*'\r\n    var arglist = {\r\n      pattern: RegExp(par + nestedPar + endpar),\r\n      lookbehind: true,\r\n      inside: {\r\n        'rest-vars': {\r\n          pattern: RegExp('&(?:body|rest)\\\\s+' + forms),\r\n          inside: arg\r\n        },\r\n        'other-marker-vars': {\r\n          pattern: RegExp('&(?:aux|optional)\\\\s+' + forms),\r\n          inside: arg\r\n        },\r\n        keys: {\r\n          pattern: RegExp('&key\\\\s+' + forms + '(?:\\\\s+&allow-other-keys)?'),\r\n          inside: arg\r\n        },\r\n        argument: {\r\n          pattern: RegExp(symbol),\r\n          alias: 'variable'\r\n        },\r\n        punctuation: /[()]/\r\n      }\r\n    }\r\n    language['lambda'].inside.arguments = arglist\r\n    language['defun'].inside.arguments = Prism.util.clone(arglist)\r\n    language['defun'].inside.arguments.inside.sublist = arglist\r\n    Prism.languages.lisp = language\r\n    Prism.languages.elisp = language\r\n    Prism.languages.emacs = language\r\n    Prism.languages['emacs-lisp'] = language\r\n  })(Prism)\r\n}\r\n"],
  "mappings": "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",
  "names": ["Prism"]
}
