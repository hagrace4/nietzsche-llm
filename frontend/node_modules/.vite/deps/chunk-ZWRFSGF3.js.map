{
  "version": 3,
  "sources": ["../../refractor/lang/http.js"],
  "sourcesContent": ["'use strict'\r\n\r\nmodule.exports = http\r\nhttp.displayName = 'http'\r\nhttp.aliases = []\r\nfunction http(Prism) {\r\n  ;(function (Prism) {\r\n    /**\r\n     * @param {string} name\r\n     * @returns {RegExp}\r\n     */\r\n    function headerValueOf(name) {\r\n      return RegExp('(^(?:' + name + '):[ \\t]*(?![ \\t]))[^]+', 'i')\r\n    }\r\n    Prism.languages.http = {\r\n      'request-line': {\r\n        pattern:\r\n          /^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\\s(?:https?:\\/\\/|\\/)\\S*\\sHTTP\\/[\\d.]+/m,\r\n        inside: {\r\n          // HTTP Method\r\n          method: {\r\n            pattern: /^[A-Z]+\\b/,\r\n            alias: 'property'\r\n          },\r\n          // Request Target e.g. http://example.com, /path/to/file\r\n          'request-target': {\r\n            pattern: /^(\\s)(?:https?:\\/\\/|\\/)\\S*(?=\\s)/,\r\n            lookbehind: true,\r\n            alias: 'url',\r\n            inside: Prism.languages.uri\r\n          },\r\n          // HTTP Version\r\n          'http-version': {\r\n            pattern: /^(\\s)HTTP\\/[\\d.]+/,\r\n            lookbehind: true,\r\n            alias: 'property'\r\n          }\r\n        }\r\n      },\r\n      'response-status': {\r\n        pattern: /^HTTP\\/[\\d.]+ \\d+ .+/m,\r\n        inside: {\r\n          // HTTP Version\r\n          'http-version': {\r\n            pattern: /^HTTP\\/[\\d.]+/,\r\n            alias: 'property'\r\n          },\r\n          // Status Code\r\n          'status-code': {\r\n            pattern: /^(\\s)\\d+(?=\\s)/,\r\n            lookbehind: true,\r\n            alias: 'number'\r\n          },\r\n          // Reason Phrase\r\n          'reason-phrase': {\r\n            pattern: /^(\\s).+/,\r\n            lookbehind: true,\r\n            alias: 'string'\r\n          }\r\n        }\r\n      },\r\n      header: {\r\n        pattern: /^[\\w-]+:.+(?:(?:\\r\\n?|\\n)[ \\t].+)*/m,\r\n        inside: {\r\n          'header-value': [\r\n            {\r\n              pattern: headerValueOf(/Content-Security-Policy/.source),\r\n              lookbehind: true,\r\n              alias: ['csp', 'languages-csp'],\r\n              inside: Prism.languages.csp\r\n            },\r\n            {\r\n              pattern: headerValueOf(/Public-Key-Pins(?:-Report-Only)?/.source),\r\n              lookbehind: true,\r\n              alias: ['hpkp', 'languages-hpkp'],\r\n              inside: Prism.languages.hpkp\r\n            },\r\n            {\r\n              pattern: headerValueOf(/Strict-Transport-Security/.source),\r\n              lookbehind: true,\r\n              alias: ['hsts', 'languages-hsts'],\r\n              inside: Prism.languages.hsts\r\n            },\r\n            {\r\n              pattern: headerValueOf(/[^:]+/.source),\r\n              lookbehind: true\r\n            }\r\n          ],\r\n          'header-name': {\r\n            pattern: /^[^:]+/,\r\n            alias: 'keyword'\r\n          },\r\n          punctuation: /^:/\r\n        }\r\n      }\r\n    } // Create a mapping of Content-Type headers to language definitions\r\n    var langs = Prism.languages\r\n    var httpLanguages = {\r\n      'application/javascript': langs.javascript,\r\n      'application/json': langs.json || langs.javascript,\r\n      'application/xml': langs.xml,\r\n      'text/xml': langs.xml,\r\n      'text/html': langs.html,\r\n      'text/css': langs.css,\r\n      'text/plain': langs.plain\r\n    } // Declare which types can also be suffixes\r\n    var suffixTypes = {\r\n      'application/json': true,\r\n      'application/xml': true\r\n    }\r\n    /**\r\n     * Returns a pattern for the given content type which matches it and any type which has it as a suffix.\r\n     *\r\n     * @param {string} contentType\r\n     * @returns {string}\r\n     */\r\n    function getSuffixPattern(contentType) {\r\n      var suffix = contentType.replace(/^[a-z]+\\//, '')\r\n      var suffixPattern = '\\\\w+/(?:[\\\\w.-]+\\\\+)+' + suffix + '(?![+\\\\w.-])'\r\n      return '(?:' + contentType + '|' + suffixPattern + ')'\r\n    } // Insert each content type parser that has its associated language\r\n    // currently loaded.\r\n    var options\r\n    for (var contentType in httpLanguages) {\r\n      if (httpLanguages[contentType]) {\r\n        options = options || {}\r\n        var pattern = suffixTypes[contentType]\r\n          ? getSuffixPattern(contentType)\r\n          : contentType\r\n        options[contentType.replace(/\\//g, '-')] = {\r\n          pattern: RegExp(\r\n            '(' +\r\n              /content-type:\\s*/.source +\r\n              pattern +\r\n              /(?:(?:\\r\\n?|\\n)[\\w-].*)*(?:\\r(?:\\n|(?!\\n))|\\n)/.source +\r\n              ')' + // This is a little interesting:\r\n              // The HTTP format spec required 1 empty line before the body to make everything unambiguous.\r\n              // However, when writing code by hand (e.g. to display on a website) people can forget about this,\r\n              // so we want to be liberal here. We will allow the empty line to be omitted if the first line of\r\n              // the body does not start with a [\\w-] character (as headers do).\r\n              /[^ \\t\\w-][\\s\\S]*/.source,\r\n            'i'\r\n          ),\r\n          lookbehind: true,\r\n          inside: httpLanguages[contentType]\r\n        }\r\n      }\r\n    }\r\n    if (options) {\r\n      Prism.languages.insertBefore('http', 'header', options)\r\n    }\r\n  })(Prism)\r\n}\r\n"],
  "mappings": ";;;;;AAAA;AAAA;AAEA,WAAO,UAAU;AACjB,SAAK,cAAc;AACnB,SAAK,UAAU,CAAC;AAChB,aAAS,KAAK,OAAO;AACnB;AAAC,OAAC,SAAUA,QAAO;AAKjB,iBAAS,cAAc,MAAM;AAC3B,iBAAO,OAAO,UAAU,OAAO,wBAA0B,GAAG;AAAA,QAC9D;AACA,QAAAA,OAAM,UAAU,OAAO;AAAA,UACrB,gBAAgB;AAAA,YACd,SACE;AAAA,YACF,QAAQ;AAAA;AAAA,cAEN,QAAQ;AAAA,gBACN,SAAS;AAAA,gBACT,OAAO;AAAA,cACT;AAAA;AAAA,cAEA,kBAAkB;AAAA,gBAChB,SAAS;AAAA,gBACT,YAAY;AAAA,gBACZ,OAAO;AAAA,gBACP,QAAQA,OAAM,UAAU;AAAA,cAC1B;AAAA;AAAA,cAEA,gBAAgB;AAAA,gBACd,SAAS;AAAA,gBACT,YAAY;AAAA,gBACZ,OAAO;AAAA,cACT;AAAA,YACF;AAAA,UACF;AAAA,UACA,mBAAmB;AAAA,YACjB,SAAS;AAAA,YACT,QAAQ;AAAA;AAAA,cAEN,gBAAgB;AAAA,gBACd,SAAS;AAAA,gBACT,OAAO;AAAA,cACT;AAAA;AAAA,cAEA,eAAe;AAAA,gBACb,SAAS;AAAA,gBACT,YAAY;AAAA,gBACZ,OAAO;AAAA,cACT;AAAA;AAAA,cAEA,iBAAiB;AAAA,gBACf,SAAS;AAAA,gBACT,YAAY;AAAA,gBACZ,OAAO;AAAA,cACT;AAAA,YACF;AAAA,UACF;AAAA,UACA,QAAQ;AAAA,YACN,SAAS;AAAA,YACT,QAAQ;AAAA,cACN,gBAAgB;AAAA,gBACd;AAAA,kBACE,SAAS,cAAc,0BAA0B,MAAM;AAAA,kBACvD,YAAY;AAAA,kBACZ,OAAO,CAAC,OAAO,eAAe;AAAA,kBAC9B,QAAQA,OAAM,UAAU;AAAA,gBAC1B;AAAA,gBACA;AAAA,kBACE,SAAS,cAAc,mCAAmC,MAAM;AAAA,kBAChE,YAAY;AAAA,kBACZ,OAAO,CAAC,QAAQ,gBAAgB;AAAA,kBAChC,QAAQA,OAAM,UAAU;AAAA,gBAC1B;AAAA,gBACA;AAAA,kBACE,SAAS,cAAc,4BAA4B,MAAM;AAAA,kBACzD,YAAY;AAAA,kBACZ,OAAO,CAAC,QAAQ,gBAAgB;AAAA,kBAChC,QAAQA,OAAM,UAAU;AAAA,gBAC1B;AAAA,gBACA;AAAA,kBACE,SAAS,cAAc,QAAQ,MAAM;AAAA,kBACrC,YAAY;AAAA,gBACd;AAAA,cACF;AAAA,cACA,eAAe;AAAA,gBACb,SAAS;AAAA,gBACT,OAAO;AAAA,cACT;AAAA,cACA,aAAa;AAAA,YACf;AAAA,UACF;AAAA,QACF;AACA,YAAI,QAAQA,OAAM;AAClB,YAAI,gBAAgB;AAAA,UAClB,0BAA0B,MAAM;AAAA,UAChC,oBAAoB,MAAM,QAAQ,MAAM;AAAA,UACxC,mBAAmB,MAAM;AAAA,UACzB,YAAY,MAAM;AAAA,UAClB,aAAa,MAAM;AAAA,UACnB,YAAY,MAAM;AAAA,UAClB,cAAc,MAAM;AAAA,QACtB;AACA,YAAI,cAAc;AAAA,UAChB,oBAAoB;AAAA,UACpB,mBAAmB;AAAA,QACrB;AAOA,iBAAS,iBAAiBC,cAAa;AACrC,cAAI,SAASA,aAAY,QAAQ,aAAa,EAAE;AAChD,cAAI,gBAAgB,0BAA0B,SAAS;AACvD,iBAAO,QAAQA,eAAc,MAAM,gBAAgB;AAAA,QACrD;AAEA,YAAI;AACJ,iBAAS,eAAe,eAAe;AACrC,cAAI,cAAc,WAAW,GAAG;AAC9B,sBAAU,WAAW,CAAC;AACtB,gBAAI,UAAU,YAAY,WAAW,IACjC,iBAAiB,WAAW,IAC5B;AACJ,oBAAQ,YAAY,QAAQ,OAAO,GAAG,CAAC,IAAI;AAAA,cACzC,SAAS;AAAA,gBACP,MACE,mBAAmB,SACnB,UACA,iDAAiD,SACjD;AAAA;AAAA;AAAA;AAAA;AAAA,gBAKA,mBAAmB;AAAA,gBACrB;AAAA,cACF;AAAA,cACA,YAAY;AAAA,cACZ,QAAQ,cAAc,WAAW;AAAA,YACnC;AAAA,UACF;AAAA,QACF;AACA,YAAI,SAAS;AACX,UAAAD,OAAM,UAAU,aAAa,QAAQ,UAAU,OAAO;AAAA,QACxD;AAAA,MACF,GAAG,KAAK;AAAA,IACV;AAAA;AAAA;",
  "names": ["Prism", "contentType"]
}
